package main

import (
  "fmt"
  "io"
  "net/http"
  "os"
  "path/filepath"
  "strings"
  "gopkg.in/yaml.v3"
)

type EmbedConfig struct {
  GoOutput string   `yaml:"go-output"`
  Output  string   `yaml:"output"`
  Files   []string `yaml:"files"`
}

func main() {
  // 1. Read embed.yaml in current directory (for use from examples/basic)
  cwd, _ := os.Getwd()
  configPath := filepath.Join(cwd, "embed.yaml")
  if _, err := os.Stat(configPath); os.IsNotExist(err) {
    fmt.Fprintln(os.Stderr, "embed.yaml not found in current directory")
    os.Exit(1)
  }
  configData, err := os.ReadFile(configPath)
  if err != nil {
    fmt.Fprintf(os.Stderr, "failed to read %s: %v\n", configPath, err)
    os.Exit(1)
  }
  var cfg EmbedConfig
  if err := yaml.Unmarshal(configData, &cfg); err != nil {
    fmt.Fprintf(os.Stderr, "failed to parse %s: %v\n", configPath, err)
    os.Exit(1)
  }
  if cfg.GoOutput == "" {
    cfg.GoOutput = "embed.go"
  }
  if len(cfg.Files) == 0 {
    fmt.Fprintln(os.Stderr, "No files specified in embed.yaml")
    os.Exit(1)
  }

  // 2. Download files and write to output dir (relative to cwd)
  outDir := cfg.Output
  if outDir == "" {
    outDir = "."
  }
  var embedVars []string
  for _, fileURL := range cfg.Files {
    if !strings.HasPrefix(fileURL, "http://") && !strings.HasPrefix(fileURL, "https://") {
      fmt.Fprintf(os.Stderr, "unsupported file source: %s\n", fileURL)
      continue
    }
    parts := strings.Split(fileURL, "/")
    shortName := parts[len(parts)-1]
    outPath := strings.ReplaceAll(outDir, "<short_name>", strings.TrimSuffix(shortName, filepath.Ext(shortName)))
    absOutPath := filepath.Join(cwd, outPath)
    if err := os.MkdirAll(absOutPath, 0755); err != nil {
      fmt.Fprintf(os.Stderr, "failed to create dir %s: %v\n", absOutPath, err)
      os.Exit(1)
    }
    localFile := filepath.Join(absOutPath, shortName)
    resp, err := http.Get(fileURL)
    if err != nil {
      fmt.Fprintf(os.Stderr, "failed to download %s: %v\n", fileURL, err)
      os.Exit(1)
    }
    defer resp.Body.Close()
    if resp.StatusCode != 200 {
      fmt.Fprintf(os.Stderr, "failed to download %s: %s\n", fileURL, resp.Status)
      os.Exit(1)
    }
    f, err := os.Create(localFile)
    if err != nil {
      fmt.Fprintf(os.Stderr, "failed to create file %s: %v\n", localFile, err)
      os.Exit(1)
    }
    _, err = io.Copy(f, resp.Body)
    f.Close()
    if err != nil {
      fmt.Fprintf(os.Stderr, "failed to write file %s: %v\n", localFile, err)
      os.Exit(1)
    }
    varName := toGoVarName(shortName)
    // Use relative path for go:embed
    relEmbedPath := filepath.ToSlash(filepath.Join(outPath, shortName))
    embedVars = append(embedVars, fmt.Sprintf("//go:embed %s\nvar %s string\n", relEmbedPath, varName))
  }

  // 3. Detect package name from go.mod in cwd (if present)
  pkgName := "main"
  gomodPath := filepath.Join(cwd, "go.mod")
  if data, err := os.ReadFile(gomodPath); err == nil {
    lines := strings.Split(string(data), "\n")
    for _, l := range lines {
      l = strings.TrimSpace(l)
      if strings.HasPrefix(l, "module ") {
        parts := strings.Split(l, "/")
        pkgName = parts[len(parts)-1]
        pkgName = strings.ReplaceAll(pkgName, "-", "_")
        break
      }
    }
  }

  // 4. Generate embed.go in cwd
  embedGo := fmt.Sprintf("package %s\n\nimport (\n\t_ \"embed\"\n)\n\n// Embedded assets generated by remoteembed\n\n", pkgName)
  for _, v := range embedVars {
    embedGo += v + "\n"
  }
  embedGoPath := filepath.Join(cwd, cfg.GoOutput)
  if err := os.WriteFile(embedGoPath, []byte(embedGo), 0644); err != nil {
    fmt.Fprintf(os.Stderr, "failed to write %s: %v\n", embedGoPath, err)
    os.Exit(1)
  }
}

// toGoVarName converts a file name to a Go exported variable name
func toGoVarName(name string) string {
  name = strings.TrimSuffix(name, filepath.Ext(name))
  name = strings.ReplaceAll(name, "-", "_")
  name = strings.ReplaceAll(name, ".", "_")
  name = strings.Title(name)
  return name
}
